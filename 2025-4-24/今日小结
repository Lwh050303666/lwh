char * strcpy ( char * destination, const char * source ); /* 将source 指向的 C 字符串复制到destination指向的数组中，包括终止空字符（并在该位置停止）。为避免溢出， destination

指向的数组大小应足够长，以包含与source相同的 C 字符串（包括终止空字符），并且不应与source在内存中重叠。*/
void * memcpy ( void * destination, const void * source, size_t num );   /*将num 个字节 的值从source指向的位置直接复制到destination指向的内存块。源指针和目标

指针 指向的对象的基础类型与此函数无关；结果是数据的二进制副本。 该函数不会检查source中是否存在任何终止空字符- 它始终复制num 个字节。为避免溢出，目标和源参数 指向的数组的大小应至少为num 个字节，并且不应重叠*/
void * memset ( void * ptr, int value, size_t num ); /*将ptr指向的内存块的 前num个字节设置为指定值（解释为unsigned char）。*/
void perror ( const char * str );/*打印错误信息
将errno 的值解释为错误消息，并将其打印到stderr（标准错误输出流，通常是控制台），可选择在其前面加上str中指定的自定义消息。

errno是一个整数变量，其值描述调用库函数时产生的错误条件或诊断信息（C 标准库的任何函数都可以设置errno的值，即使本参考中未明确指定，即使没有发生错误），有关详细信息，请参阅errno 。 perror

生成的错误消息取决于平台。 如果参数str不是空指针，则打印str，后跟冒号（:) 和空格。然后，无论str是否为空指针，都会打印生成的错误描述，后跟换行符（'\n'）。在错误产生后应立即调用perror，否则它可能会被对其他函数的调用覆盖。8/
void* realloc(void* ptr，size_t size);/* 更改ptr 指向的内存块的大小。

该函数可能会将内存块移动到新位置（其地址由函数返回）。  如果成功移动到新位置那么原位置将会被自动释放.如果函数无法分配请求的内存块，则返回空指针，并且参数ptr 指向的内存块不会被释放（它仍然有效，并且其内容不变）。*/
void*calloc(size_t num，size_t size)；/*分配并初始化数组
为一个包含num 个元素 的数组分配一块内存，每个元素的长度为 size字节，并将其所有位初始化为零。

实际结果是分配一个初始化为零的(num*size)字节内存块。

如果size为零，则返回值取决于具体的库实现（可能是也可能不是空指针），但返回的指针不应被取消引用。*/
void assert (int expression);/*如果该宏的函数形式参数表达式等于零（即表达式为false），则将消息写入标准错误设备，并且中止被调用，终止程序执行。*/
结构体的对其规则：1. 第一个成员在与结构体偏移量为0的地址处。

2. 其他成员变量要对齐到有效对齐数的整数倍的地址处。

注意：有效对齐数 = 编译器默认的一个对齐数 与 该成员所占字节数的较小值。

        64位操作系统默认的对齐数为8，32位的为4

3. 结构体总大小为：最大对齐数（所有变量类型所占字节数最大者与默认对齐参数取最小）的整数倍。

4. 如果嵌套了结构体的情况，嵌套的结构体对齐到自己的最大对齐数（该结构体内所有变量类型所占字节数最大者与默认对齐参数取最小）的整数倍处，结构体的整体大小就是所有最大对齐数（含嵌套结构体的对齐数）的整数倍。

其中编译器默认的对齐数是可以通过#pragma pack (n)来指定对齐数
———————————————
1. 第一个成员在与结构体偏移量为0的地址处。

2. 其他成员变量要对齐到有效对齐数的整数倍的地址处。

注意：有效对齐数 = 编译器默认的一个对齐数 与 该成员所占字节数的较小值。

        64位操作系统默认的对齐数为8，32位的为4

3. 结构体总大小为：最大对齐数（所有变量类型所占字节数最大者与默认对齐参数取最小）的整数倍。

4. 如果嵌套了结构体的情况，嵌套的结构体对齐到自己的最大对齐数（该结构体内所有变量类型所占字节数最大者与默认对齐参数取最小）的整数倍处，结构体的整体大小就是所有最大对齐数（含嵌套结构体的对齐数）的整数倍。

其中编译器默认的对齐数是可以通过#pragma pack (n)来指定对齐数
————————————————


大端是高字节存放到内存的低地址

小端是高字节存放到内存的高地址     //如何确定大小端
#include <stdio.h>
 
// 共用体中很重要的一点：a和b都是从u1的低地址开始存放的。
// 假设u1所在的4字节地址分别是：0、1、2、3的话，那么a自然就是0、1、2、3；
// b所在的地址是0而不是3.
 
union myunion
{
	int a;
	char b;
};
 
// 如果是小端模式则返回1，小端模式则返回0
int is_little_endian(void)
{
	union myunion u1;
	u1.a = 0x12345678;				// 地址0的那个字节内是0x78（小端）或者0x12（大端）
    if(0x78 == u1.b)
        return 1;
    else if(0x12 == u1.b)
	    return 0;
}
 
int is_little_endian2(void)
{
	int a = 0x12345678;
	char b = *((char *)(&a));		// 指针方式其实就是共用体的本质
	if(0x78 == b)
        return 1;
    else if(0x12 == b)
	    return 0;
}
 
 
int main(void)
{
	int i = is_little_endian2();
	//int i = is_little_endian();
	if (i == 1)
	{
		printf("小端模式\n");
	}
	else
	{
		printf("大端模式\n");
	}
	
	return 0;
}


今天确定了自己的人生目标，那就是我要尽可能地创办一家伟大的企业，获取更多的社会资源，这倒不是说我贪婪，人的欲望是无止境的，钱这玩意对我来说差不多够用就行，然而，我却可以利用这些社会资源把它们分配给其他那些受苦受难的人，当然是一件十分值得欢喜的事，同时希望自己在追梦的过程中一路顺遂。





          
