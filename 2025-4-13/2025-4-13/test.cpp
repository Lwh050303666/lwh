//构造函数可以重载     为的是可以支持多种初始化方式
//构造函数的调用跟普通函数也不一样       
//#include<iostream>
//using namespace std;
//struct Date
//{public:
//	Date() {
//		_year = 1;
//		_month = 1;
//		_day = 1;
//		//这是构造函数
//}
//	Date(int year = 1, int month = 1, int day = 1) {
//		_year = year;
//		_month = month;
//		_day = day; //全缺省和无参的构造函数同时存在时会有歧义
//	}
//	Date(Date d) {
//		_year = d._year;
//		_month = d._month;
//		_day = d._day;
//	}
//private:
//	int _year = 1;
//	int _month = 1;
//	int _day = 1;
//};
//
//Date d1;
//Date d2(2023, 1, 1);//构造函数的调用跟普通函数的调用不同  用对象加参数列表调用构造函数而不是函数名
//
////Date d3();//这种写法是错误的    没参数的时候不能加括号     这样写会和函数声明有冲突
////无参的构造函数和全缺省的构造函数都称为是默认构造函数，并且默认构造函数只能有一个，注意：无参构造函数，全缺省构造函数，我们不写编译器自动生成的都是默认构造函数
////简单来说默认构造函数就是可以不传参也可以调用的构造函数
// 
////编译器默认生成的构造函数对内置类型不做处理（有些编译器会处理，但这是个人行为不是普遍行为）
////自定义类型会去调用它的默认构造
////析构函数不可以重载，因为它没有参数
////一般情况下，有动态申请的资源，就需要写析构函数释放资源
////2.没有动态申请的资源不需要写析构
//   
//Date d2(d1);//拷贝构造是构造函数的一种重载形式
////拷贝构造函数的参数只有一个且必须是类类型对象的引用，使用传值方式编译器会直接报错，因为会引发无穷递归调用
//内置类型的传递可以直接拷贝过去，而自定义类型的传递必须进行拷贝构造
//若未显示定义，编译器会生成默认的拷贝构造函数，默认的拷贝构造函数对象按内存存储按字节序完成拷贝，这种拷贝叫做浅拷贝，或者值拷贝



//作为类的成员函数重载时，其形参看起来比操作数数目少1，因为成员函数的第一个参数为隐藏的this指针
//重载操作符必须有一个类类型参数
//赋值运算符重载本质上是一种操作符重载
//默认生成赋值重载跟拷贝构造行为一样
//内置类型成员   值拷贝
//自定义类型调用它的赋值重载
//默认生成的赋值重载满足连续赋值的规则
//赋值运算符重载不能写到全局  因为它是默认成员函数 写到全局以后类内部会再默认生成一个，这样就会导致冲突
//static int ar[]的作用是如果不是静态的并且arr数组被频繁使用的话就会频繁地创建
//用static修饰以后就可以一劳永逸


//运算符重载和函数重载是不一样的
//前置++和后置++的重载    
//Date& Date:: operator++() {
//	*this += 1;//前置++
//	return *this;
//}
//
////下面是后置++
//Date Date:: operator++(int) {
//	Date tmp = *this;
//	*this += 1;
//	return tmp;//后置++比较特殊
//}
//
//
////前置++和后置++的使用
//d1.operator++();//前置++
//d2.operator++(0);//后置++



//Date& Date::operator-=(int day)
//{
//	_day -= day;
//	while (_day <= 0)
//	{
//		--_month;
//		if (_month == 0)
//		{
//			_month = 12;
//			--_year;
//		}
//		_day = GetMonthDay(_year,_month);
//	}
//}
//Date Date::operator (int day)
//{
//
//}



//流插入不能写成成员函数   因为Date对象默认占用第一个参数，就是做了左操作数


//class  A {
//	
//public:
//	void print()const{    //这个const修饰的是*this
//		cout<<   <<;
//	}
//};





//每个成员变量在初始化列表中最多只能出现一次（初始化只能初始化一次）
// 类中包含以下成员，必须放在初始化列表位置进行初始化
// 1.引用成员变量
// 2.const成员变量
// 3.自定义类型成员（且该类没有默认构造函数时）		
//初始化列表是对象的成员定义的位置
class A
{
public:
	A(int a = 0)
		:_a(a)
	{
		cout << "A(int a=0)" << endl;
	}
private:
	int _a;
};


class B
{
public:
	B(int a, int ref)
		:_ref(ref)
		, _n(1)
		, _x(2)
		, _aobj(10) //调用A的默认构造


private:
		A _aobj;
};



















