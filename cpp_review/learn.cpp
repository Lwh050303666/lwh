// // // // // // // // // // // // // // // // // // // // // // // // // #include <iostream>
// // // // // // // // // // // // // // // // // // // // // // // // // #include <memory>  // 需要包含memory头文件
// // // // // // // // // // // // // // // // // // // // // // // // // using namespace std;

// // // // // // // // // // // // // // // // // // // // // // // // // // shared_ptr<int>ptr1(new int(10));//shared_ptr 当计数减到0时自动释放
// // // // // // // // // // // // // // // // // // // // // // // // // // unique_ptr<int>ptr2(new int(20));//unique_ptr 当指针的作用域被销毁就自动释放
    

// // // // // // // // // // // // // // // // // // // // // // // // // // try{

// // // // // // // // // // // // // // // // // // // // // // // // // // }
// // // // // // // // // // // // // // // // // // // // // // // // // // catch(const runtime_error &e){

// // // // // // // // // // // // // // // // // // // // // // // // // // }
// // // // // // // // // // // // // // // // // // // // // // // // // // class my_exception:public runtime_error{
// // // // // // // // // // // // // // // // // // // // // // // // // //     public:  my_exception(const char * msg ):runtime_error(msg){};
    

// // // // // // // // // // // // // // // // // // // // // // // // // // }
// // // // // // // // // // // // // // // // // // // // // // // // // // //You must doing something,bro.
// // // // // // // // // // // // // // // // // // // // // // // // // // //Just do it.To do the right thing

// // // // // // // // // // // // // // // // // // // // // // // // // // []()->return {}
// // // // // // // // // // // // // // // // // // // // // // // // // // int removeDuplicates(int *nums,int numsSize){
// // // // // // // // // // // // // // // // // // // // // // // // // //     if(nums==nullptr ||numsSize<=0)  return 0;
// // // // // // // // // // // // // // // // // // // // // // // // // //     int slow=0,fast=1;
// // // // // // // // // // // // // // // // // // // // // // // // // //     while(fast<numsSize){
// // // // // // // // // // // // // // // // // // // // // // // // // //         if(nums[slow]<nums[fast]){
// // // // // // // // // // // // // // // // // // // // // // // // // //             nums[slow+1]=nums[fast];
// // // // // // // // // // // // // // // // // // // // // // // // // //             fast++,slow++;   continue;
// // // // // // // // // // // // // // // // // // // // // // // // // //         }
// // // // // // // // // // // // // // // // // // // // // // // // // //         fast++;
// // // // // // // // // // // // // // // // // // // // // // // // // //     }
// // // // // // // // // // // // // // // // // // // // // // // // // //     return  slow+1;
// // // // // // // // // // // // // // // // // // // // // // // // // // }
// // // // // // // // // // // // // // // // // // // // // // // // // // int main(){
// // // // // // // // // // // // // // // // // // // // // // // // // //     int nums[8]={0,0,1,1,2,2};
// // // // // // // // // // // // // // // // // // // // // // // // // //     removeDuplicates(nums,6);
// // // // // // // // // // // // // // // // // // // // // // // // // //     return 0;
// // // // // // // // // // // // // // // // // // // // // // // // // // }

// // // // // // // // // // // // // // // // // // // // // // // // // // int removeElement(int * nums,int numsSize,int val){
// // // // // // // // // // // // // // // // // // // // // // // // // //     int cnt=0;
// // // // // // // // // // // // // // // // // // // // // // // // // //     for(int i=0;i<numsSize;i++){
// // // // // // // // // // // // // // // // // // // // // // // // // //         if(nums[i]==val){
// // // // // // // // // // // // // // // // // // // // // // // // // //             cnt++;
// // // // // // // // // // // // // // // // // // // // // // // // // //             for(int j=i;j<numsSize-1;j++)  //从前往后  往前挪一位
// // // // // // // // // // // // // // // // // // // // // // // // // // {
// // // // // // // // // // // // // // // // // // // // // // // // // //     nums[j]=nums[j+1];
// // // // // // // // // // // // // // // // // // // // // // // // // // }
// // // // // // // // // // // // // // // // // // // // // // // // // //         }
// // // // // // // // // // // // // // // // // // // // // // // // // //     }int ans=numsSize-cnt;  
// // // // // // // // // // // // // // // // // // // // // // // // // //     return ans ;
// // // // // // // // // // // // // // // // // // // // // // // // // // }
// // // // // // // // // // // // // // // // // // // // // // // // // // int removeElement(int *nums,int numsSize,int val){
// // // // // // // // // // // // // // // // // // // // // // // // // //     int slow=0;
// // // // // // // // // // // // // // // // // // // // // // // // // //     for(int fast=0;fast<numsSize;fast++){
// // // // // // // // // // // // // // // // // // // // // // // // // //         if(nums[fast]!=val){
// // // // // // // // // // // // // // // // // // // // // // // // // //             nums[slow]=nums[fast];
// // // // // // // // // // // // // // // // // // // // // // // // // //             slow++;
// // // // // // // // // // // // // // // // // // // // // // // // // //         }
// // // // // // // // // // // // // // // // // // // // // // // // // //     }
// // // // // // // // // // // // // // // // // // // // // // // // // //     return slow;
// // // // // // // // // // // // // // // // // // // // // // // // // //
// // // // // // // // // // // // // // // // // // // // // // // // // // void merge(int *nums1,int nums1Size,int m,int * nums2,int nums2Size,int n){
// // // // // // // // // // // // // // // // // // // // // // // // // //     int end1=m-1,end2=n-1;
// // // // // // // // // // // // // // // // // // // // // // // // // //     int dst=m+n-1;
// // // // // // // // // // // // // // // // // // // // // // // // // //     while(end1>=0&&end2>=0){
// // // // // // // // // // // // // // // // // // // // // // // // // //         if(nums1[end1]>nums2[end2]){
// // // // // // // // // // // // // // // // // // // // // // // // // //             nums1[dst--]=nums1[end1--];
// // // // // // // // // // // // // // // // // // // // // // // // // //         }
// // // // // // // // // // // // // // // // // // // // // // // // // //         else {
// // // // // // // // // // // // // // // // // // // // // // // // // //             nums1[dst--]=nums2[end2--];
// // // // // // // // // // // // // // // // // // // // // // // // // //         }

// // // // // // // // // // // // // // // // // // // // // // // // // //     }
// // // // // // // // // // // // // // // // // // // // // // // // // //     while(end2>=0)  nums1[dst--]=nums2[end2--];

// // // // // // // // // // // // // // // // // // // // // // // // // // }
// // // // // // // // // // // // // // // // // // // // // // // // // #pragma once
// // // // // // // // // // // // // // // // // // // // // // // // // #include<stdio.h>
// // // // // // // // // // // // // // // // // // // // // // // // // #include<stdlib.h>
// // // // // // // // // // // // // // // // // // // // // // // // // #include<assert.h>

// // // // // // // // // // // // // // // // // // // // // // // // // typedef int SLDataType;
// // // // // // // // // // // // // // // // // // // // // // // // // #define N 100000
// // // // // // // // // // // // // // // // // // // // // // // // // //
// // // // // // // // // // // // // // // // // // // // // // // // // //静态顺序表 -- 开少了不够用  开多了浪费
// // // // // // // // // // // // // // // // // // // // // // // // // //struct SeqList{
// // // // // // // // // // // // // // // // // // // // // // // // //     SLDataType a[N];
// // // // // // // // // // // // // // // // // // // // // // // // //   int size;
// // // // // // // // // // // // // // // // // // // // // // // // // };
// // // // // // // // // // // // // // // // // // // // // // // // // typedef int SLDataType;
// // // // // // // // // // // // // // // // // // // // // // // // // #define INIT_CAPACITY 4

// // // // // // // // // // // // // // // // // // // // // // // // // typedef struct SeqList{
// // // // // // // // // // // // // // // // // // // // // // // // // SLDataType *a;
// // // // // // // // // // // // // // // // // // // // // // // // // int size;
// // // // // // // // // // // // // // // // // // // // // // // // // int capacity;
// // // // // // // // // // // // // // // // // // // // // // // // // }SL;
// // // // // // // // // // // // // // // // // // // // // // // // // //增删查改
// // // // // // // // // // // // // // // // // // // // // // // // // void SLInit(SL * ps);
// // // // // // // // // // // // // // // // // // // // // // // // // void SLDestroy(SL * ps);
// // // // // // // // // // // // // // // // // // // // // // // // // void SLCheckCapacity(SL* ps);

// // // // // // // // // // // // // // // // // // // // // // // // // void SLPushBack(SL* ps, SLDataType x);
// // // // // // // // // // // // // // // // // // // // // // // // // void SLPopBack(SL* ps);
// // // // // // // // // // // // // // // // // // // // // // // // // void SLPushFront(SL* ps, SLDataType x);
// // // // // // // // // // // // // // // // // // // // // // // // // void SLPopFront(SL* ps);
// // // // // // // // // // // // // // // // // // // // // // // // // void SLInsert(SL* ps, int pos, SLDataType x);
// // // // // // // // // // // // // // // // // // // // // // // // // void SLErase(SL* ps, int pos);
// // // // // // // // // // // // // // // // // // // // // // // // // int SLFind(SL* ps, SLDataType x);


// // // // // // // // // // // // // // // // // // // // // // // // // #include<SeqList.h>
// // // // // // // // // // // // // // // // // // // // // // // // // void SLInit(SL * ps){
// // // // // // // // // // // // // // // // // // // // // // // // //   assert(ps);
// // // // // // // // // // // // // // // // // // // // // // // // //  ps->a= (SLDataType *)malloc(sizeof(SLDataType)*INIT_CAPACITY);
// // // // // // // // // // // // // // // // // // // // // // // // // if(ps->a==nullptr){
// // // // // // // // // // // // // // // // // // // // // // // // //   perror("malloc fail");
// // // // // // // // // // // // // // // // // // // // // // // // //   return;
// // // // // // // // // // // // // // // // // // // // // // // // // }
// // // // // // // // // // // // // // // // // // // // // // // // // ps->size=0;
// // // // // // // // // // // // // // // // // // // // // // // // // ps->capacity=INIT_CAPACITY;
// // // // // // // // // // // // // // // // // // // // // // // // // }

// // // // // // // // // // // // // // // // // // // // // // // // // void SLDestroy(SL* ps){
// // // // // // // // // // // // // // // // // // // // // // // // //   assert(ps);
// // // // // // // // // // // // // // // // // // // // // // // // //   ps->a=nullptr;
// // // // // // // // // // // // // // // // // // // // // // // // //   ps->size=ps->capacity=0;
// // // // // // // // // // // // // // // // // // // // // // // // // }

// // // // // // // // // // // // // // // // // // // // // // // // // void SLPrint(SL * ps){
// // // // // // // // // // // // // // // // // // // // // // // // //   assert(ps);
// // // // // // // // // // // // // // // // // // // // // // // // //   for(int i=0;i<ps->size;++i){
// // // // // // // // // // // // // // // // // // // // // // // // //     printf("%d",ps->a[i]);
// // // // // // // // // // // // // // // // // // // // // // // // //   }
// // // // // // // // // // // // // // // // // // // // // // // // //   printf("\n");
// // // // // // // // // // // // // // // // // // // // // // // // // }

// // // // // // // // // // // // // // // // // // // // // // // // // void SLCheckCapacity(SL *ps){
// // // // // // // // // // // // // // // // // // // // // // // // //   assert(ps);
// // // // // // // // // // // // // // // // // // // // // // // // //   if(ps->size==ps->capacity){
// // // // // // // // // // // // // // // // // // // // // // // // //     SLDataType * tmp=(SLDataType *)realloc(ps,sizeof(SLDataType)*2*capacity)
// // // // // // // // // // // // // // // // // // // // // // // // //     if(tmp==nullptr){
// // // // // // // // // // // // // // // // // // // // // // // // //       perror("malloc fail");
// // // // // // // // // // // // // // // // // // // // // // // // //       return;
// // // // // // // // // // // // // // // // // // // // // // // // //     }
// // // // // // // // // // // // // // // // // // // // // // // // //     ps->a=tmp;
// // // // // // // // // // // // // // // // // // // // // // // // //     ps->capacity=2*capacity;
// // // // // // // // // // // // // // // // // // // // // // // // //   }

// // // // // // // // // // // // // // // // // // // // // // // // // }

// // // // // // // // // // // // // // // // // // // // // // // // // void SLPushBack(SL * ps,SLDataType x){
// // // // // // // // // // // // // // // // // // // // // // // // //   assert(ps);
// // // // // // // // // // // // // // // // // // // // // // // // //   if(ps->size==ps->capacity)  
// // // // // // // // // // // // // // // // // // // // // // // // //   SLCheckCapacity(ps);
// // // // // // // // // // // // // // // // // // // // // // // // //   if(ps->size==ps->capacity)  return;
// // // // // // // // // // // // // // // // // // // // // // // // //   ps->a[size]=x;
// // // // // // // // // // // // // // // // // // // // // // // // //   SLInsert(ps,ps->size,x);
// // // // // // // // // // // // // // // // // // // // // // // // // }

// // // // // // // // // // // // // // // // // // // // // // // // // void SLPopBack(SL * ps){
// // // // // // // // // // // // // // // // // // // // // // // // //   assert(ps);
// // // // // // // // // // // // // // // // // // // // // // // // //   if(ps->size==0)  return;
// // // // // // // // // // // // // // // // // // // // // // // // //   ps->size--;
// // // // // // // // // // // // // // // // // // // // // // // // // }

// // // // // // // // // // // // // // // // // // // // // // // // // void SLPushFront(SL *ps,SLDataType x){
// // // // // // // // // // // // // // // // // // // // // // // // //   assert(ps);  //从后往前向后挪一位
// // // // // // // // // // // // // // // // // // // // // // // // //   SLCheckCapacity(ps);
// // // // // // // // // // // // // // // // // // // // // // // // // if(ps->size==0) {
// // // // // // // // // // // // // // // // // // // // // // // // //   ps->a[0]=x;  ps->size++;
// // // // // // // // // // // // // // // // // // // // // // // // // }
// // // // // // // // // // // // // // // // // // // // // // // // // else {
// // // // // // // // // // // // // // // // // // // // // // // // //   int end=ps->size-1;
// // // // // // // // // // // // // // // // // // // // // // // // //    while(end>=0){
// // // // // // // // // // // // // // // // // // // // // // // // //     ps->a[end+1]=ps->a[end];
// // // // // // // // // // // // // // // // // // // // // // // // //    }
// // // // // // // // // // // // // // // // // // // // // // // // //    ps->a[0]=x;
// // // // // // // // // // // // // // // // // // // // // // // // // }
// // // // // // // // // // // // // // // // // // // // // // // // // }

// // // // // // // // // // // // // // // // // // // // // // // // // void SLInsert(SL * ps,int pos,SLDataType x){
// // // // // // // // // // // // // // // // // // // // // // // // // assert(ps);
// // // // // // // // // // // // // // // // // // // // // // // // // assert(pos>=0&&pos<=ps->size-1);
// // // // // // // // // // // // // // // // // // // // // // // // // SLCheckCapacity(ps);    //从后往前向后挪一位
// // // // // // // // // // // // // // // // // // // // // // // // // int end=ps->size-1;
// // // // // // // // // // // // // // // // // // // // // // // // // while(end>=pos){
// // // // // // // // // // // // // // // // // // // // // // // // //   ps->a[end+1]==ps->a[end];
// // // // // // // // // // // // // // // // // // // // // // // // // }
// // // // // // // // // // // // // // // // // // // // // // // // // ps->a[pos]=x;
// // // // // // // // // // // // // // // // // // // // // // // // // ps->size++;
// // // // // // // // // // // // // // // // // // // // // // // // // }

// // // // // // // // // // // // // // // // // // // // // // // // // void SLErase(SL *ps,int pos){//从前往后依次往前挪一位
// // // // // // // // // // // // // // // // // // // // // // // // //       assert(ps);
      
// // // // // // // // // // // // // // // // // // // // // // // // // }

// // // // // // // // // // // // // // // // // // // // // // // // // int SLFind(SL * ps,SLDataType x){
// // // // // // // // // // // // // // // // // // // // // // // // // assert(ps);
// // // // // // // // // // // // // // // // // // // // // // // // // for(int i=0,i<ps->size;i++){
// // // // // // // // // // // // // // // // // // // // // // // // //   if(ps->a[i]==x)  return i;
// // // // // // // // // // // // // // // // // // // // // // // // // }
// // // // // // // // // // // // // // // // // // // // // // // // // return -1;

// // // // // // // // // // // // // // // // // // // // // // // // // }

// // // // // // // // // // // // // // // // // // // // // // // // //单链表
// // // // // // // // // // // // // // // // // // // // // // // // #pragma once
// // // // // // // // // // // // // // // // // // // // // // // // #include<stdio.h>
// // // // // // // // // // // // // // // // // // // // // // // // #include<stdlib.h>
// // // // // // // // // // // // // // // // // // // // // // // // #include<assert.h>
// // // // // // // // // // // // // // // // // // // // // // // // typedef int SLTDataType;
// // // // // // // // // // // // // // // // // // // // // // // // typedef struct SListNode{
// // // // // // // // // // // // // // // // // // // // // // // //   SLTDataType data;
// // // // // // // // // // // // // // // // // // // // // // // //   struct SlistNode * next;

// // // // // // // // // // // // // // // // // // // // // // // // }SLTNode;

// // // // // // // // // // // // // // // // // // // // // // // // void SLTprint(SLTNode *phead);

// // // // // // // // // // // // // // // // // // // // // // // // void SLTPushBack(SLTNode ** pphead)

// // // // // // // // // // // // // // // // // // // // // // // // SLTNode * Find(SLTNode *phead,SLTDataType x){
// // // // // // // // // // // // // // // // // // // // // // // // while(phead->next!=nullptr){
// // // // // // // // // // // // // // // // // // // // // // // //   if(phead->data!=x)  phead=phead->next;
// // // // // // // // // // // // // // // // // // // // // // // //   else  return  phead;
// // // // // // // // // // // // // // // // // // // // // // // // }
// // // // // // // // // // // // // // // // // // // // // // // // return nullptr;
// // // // // // // // // // // // // // // // // // // // // // // // }
// // // // // // // // // // // // // // // // // // // // // // // // ListNode * mergeTwoLists(struct ListNode * list1,struct ListNode  )

// // // // // // // // // // // // // // // // // // // // // // // // ListNode * partition(ListNode *phead,int x){
// // // // // // // // // // // // // // // // // // // // // // // //     struct ListNode *gGuard,*gTail,*lGuard,*lTail;
// // // // // // // // // // // // // // // // // // // // // // // //         gGuard=gTail=(struct ListNode *)malloc(sizeof(struct ListNode ));
// // // // // // // // // // // // // // // // // // // // // // // //         lGuard=lTail=(struct ListNode *)malloc(sizeof(struct ListNode ));
// // // // // // // // // // // // // // // // // // // // // // // //            struct ListNode * cur=phead;
// // // // // // // // // // // // // // // // // // // // // // // //            while(cur)
// // // // // // // // // // // // // // // // // // // // // // // //            {  if(cur->data<x){
// // // // // // // // // // // // // // // // // // // // // // // //             lTail->next=cur;
// // // // // // // // // // // // // // // // // // // // // // // //             lTail=lTail->next;}
// // // // // // // // // // // // // // // // // // // // // // // //             else {
// // // // // // // // // // // // // // // // // // // // // // // //                 gTail->next=cur;
// // // // // // // // // // // // // // // // // // // // // // // //                 gTail=gTail->next;
// // // // // // // // // // // // // // // // // // // // // // // //             }
// // // // // // // // // // // // // // // // // // // // // // // //              cur=cur->next;
// // // // // // // // // // // // // // // // // // // // // // // //            }
// // // // // // // // // // // // // // // // // // // // // // // //             lTail->next=gGuard->next;
// // // // // // // // // // // // // // // // // // // // // // // //             gTail->next=nullptr;
// // // // // // // // // // // // // // // // // // // // // // // //             phead=lGuard->next;
// // // // // // // // // // // // // // // // // // // // // // // //             free(gGuard);
// // // // // // // // // // // // // // // // // // // // // // // //             free(lGuard);
// // // // // // // // // // // // // // // // // // // // // // // //             return phead;
// // // // // // // // // // // // // // // // // // // // // // // // }


// // // // // // // // // // // // // // // // // // // // // // // // #pragma once
// // // // // // // // // // // // // // // // // // // // // // // // #include<stdio.h>
// // // // // // // // // // // // // // // // // // // // // // // // #include<stdlib.h>
// // // // // // // // // // // // // // // // // // // // // // // // #include<assert.h>
// // // // // // // // // // // // // // // // // // // // // // // // #include<stdbool.h>
// // // // // // // // // // // // // // // // // // // // // // // // typedef int LTDataType;
// // // // // // // // // // // // // // // // // // // // // // // // typedef struct ListNode{
// // // // // // // // // // // // // // // // // // // // // // // //     struct ListNode * next;
// // // // // // // // // // // // // // // // // // // // // // // //     struct ListNode * prev;
// // // // // // // // // // // // // // // // // // // // // // // //     LTDataType data;
// // // // // // // // // // // // // // // // // // // // // // // // }LTNode;
// // // // // // // // // // // // // // // // // // // // // // // // LTNode LTInit(LTNode * lt);

// // // // // // // // // // // // // // // // // // // // // // // // void LTPushBack(LTNode * phead,LTDataType x){
// // // // // // // // // // // // // // // // // // // // // // // //     assert(phead);
// // // // // // // // // // // // // // // // // // // // // // // //     LTNode * newnode=BuyListNode(x);
// // // // // // // // // // // // // // // // // // // // // // // //     LTNode * tail=phead->prev;
// // // // // // // // // // // // // // // // // // // // // // // // }



// // // // // // // // // // // // // // // // // // // // // // // //复制带随机指针的链表
// // // // // // // // // // // // // // // // // // // // // // // typedef struct {
// // // // // // // // // // // // // // // // // // // // // // //     ST pushst;
// // // // // // // // // // // // // // // // // // // // // // //     ST popst;
// // // // // // // // // // // // // // // // // // // // // // // }MyQueue;
// // // // // // // // // // // // // // // // // // // // // // // MyQueue * myQueueCreate(){
// // // // // // // // // // // // // // // // // // // // // // //     MyQueue * obj=(MyQueue *)malloc(sizeof(Myqueue));
// // // // // // // // // // // // // // // // // // // // // // //     if(obj==nullptr){
// // // // // // // // // // // // // // // // // // // // // // //         perror("malloc fail");
// // // // // // // // // // // // // // // // // // // // // // //         return nullptr;
// // // // // // // // // // // // // // // // // // // // // // //     }
// // // // // // // // // // // // // // // // // // // // // // //     STInit(&obj->pushest);
// // // // // // // // // // // // // // // // // // // // // // //     STInit(&obj->popst);
// // // // // // // // // // // // // // // // // // // // // // //     return obj;
// // // // // // // // // // // // // // // // // // // // // // // }

// // // // // // // // // // // // // // // // // // // // // // // void myQueuePush(MyQueue * obj,int x)


// // // // // // // // // // // // // // // // // // // // // // typedef int DataType;
// // // // // // // // // // // // // // // // // // // // // // struct TreeNode{
// // // // // // // // // // // // // // // // // // // // // //     struct TreeNode * firstChild1;//第一个孩子节点
// // // // // // // // // // // // // // // // // // // // // //     struct TreeNode * pNextBrother;//指向其中下一个兄弟节点
// // // // // // // // // // // // // // // // // // // // // //     DataType data;//节点中的数据域
// // // // // // // // // // // // // // // // // // // // // // }


// // // // // // // // // // // // // // // // // // // // // #pragma once
// // // // // // // // // // // // // // // // // // // // // #include<stdio.h>
// // // // // // // // // // // // // // // // // // // // // #include<stdlib.h>
// // // // // // // // // // // // // // // // // // // // // #include<stdbool.h>
// // // // // // // // // // // // // // // // // // // // // #include<assert.h>

// // // // // // // // // // // // // // // // // // // // // typedef int QDataType;
// // // // // // // // // // // // // // // // // // // // // typedef struct QueueNode{
// // // // // // // // // // // // // // // // // // // // // struct QueueNode * next;
// // // // // // // // // // // // // // // // // // // // // QDataType data;
// // // // // // // // // // // // // // // // // // // // // }QNode;

// // // // // // // // // // // // // // // // // // // // // typedef struct Queue{
// // // // // // // // // // // // // // // // // // // // //     QNode * head;
// // // // // // // // // // // // // // // // // // // // //     QNode * tail;
// // // // // // // // // // // // // // // // // // // // //     int  size;
// // // // // // // // // // // // // // // // // // // // // }Queue;

// // // // // // // // // // // // // // // // // // // // // void QueueInit(Queue * pq);


// // // // // // // // // // // // // // // // // // // // void AdjustDown(HPDataType *a,int n,int parent){
// // // // // // // // // // // // // // // // // // // // int child=parent*2+1;
// // // // // // // // // // // // // // // // // // // // while(child<n){
// // // // // // // // // // // // // // // // // // // //     if(child+1<=n&&a[child+1]>a[child])
// // // // // // // // // // // // // // // // // // // //     child++;
// // // // // // // // // // // // // // // // // // // //     if(a[child]>a[child+1]){
// // // // // // // // // // // // // // // // // // // //         swap(&a[child],&a[parent]);
// // // // // // // // // // // // // // // // // // // //         parent=child;
// // // // // // // // // // // // // // // // // // // //         child=parent*2+1;
// // // // // // // // // // // // // // // // // // // //     }
// // // // // // // // // // // // // // // // // // // //     else break;
// // // // // // // // // // // // // // // // // // // // }
// // // // // // // // // // // // // // // // // // // // }

// // // // // // // // // // // // // // // // // // // // void AdjustUp(HPDataType *a,int child){
// // // // // // // // // // // // // // // // // // // //     int parent=(child-1)/2;
// // // // // // // // // // // // // // // // // // // //     while(child>0){
// // // // // // // // // // // // // // // // // // // //         if(a[child]>a[parent]){
// // // // // // // // // // // // // // // // // // // //             swap(&a[])
// // // // // // // // // // // // // // // // // // // //         }


// // // // // // // // // // // // // // // // // // // //     }
// // // // // // // // // // // // // // // // // // // // }

// // // // // // // // // // // // // // // // // // // #pragma once
// // // // // // // // // // // // // // // // // // // #include<stdio.h>
// // // // // // // // // // // // // // // // // // // #include<stdlib.h>
// // // // // // // // // // // // // // // // // // // #include<stdbool.h>
// // // // // // // // // // // // // // // // // // // #include<assert.h>
// // // // // // // // // // // // // // // // // // // typedef int HPDataType;
// // // // // // // // // // // // // // // // // // // typedef struct Heap{
// // // // // // // // // // // // // // // // // // // HPDataType * a;
// // // // // // // // // // // // // // // // // // // int size;
// // // // // // // // // // // // // // // // // // // int capacity;
// // // // // // // // // // // // // // // // // // // }HP;

// // // // // // // // // // // // // // // // // // // void HeapInit(HP * php);
// // // // // // // // // // // // // // // // // // // void HeapDestroy(HP * php);
// // // // // // // // // // // // // // // // // // // void HeapPush(HP * php,HPDataType x);
// // // // // // // // // // // // // // // // // // // void HeapPop(HP * php);
// // // // // // // // // // // // // // // // // // // HPDataType HeapTop(HP *pop);
// // // // // // // // // // // // // // // // // // // bool HeapEmpty();
// // // // // // // // // // // // // // // // // // // int HeapSize(HP *php);
// // // // // // // // // // // // // // // // // // // void AdjustUp( )


// // // // // // // // // // // // // // // // // // //TOP-K问题



// // // // // // // // // // // // // // // // // // int TreeSize(BTNode * root){
// // // // // // // // // // // // // // // // // // return root==nullptr?0:TreeSize(root->left)+TreeSize(root->right)+1;
// // // // // // // // // // // // // // // // // // }

// // // // // // // // // // // // // // // // // // int TreeHeight(BTNode * root){
// // // // // // // // // // // // // // // // // //     if(root==nullptr)   return 0;
// // // // // // // // // // // // // // // // // //     return TreeHeight(root->left)>TreeHeight(root->right)?TreeHeight(root->left)+1:TreeHeight(root->right)+1;
// // // // // // // // // // // // // // // // // // }





// // // // // // // // // // // // // // // // // Tree * BinaryTreeFind(Tree *root,TreeDataType x){
// // // // // // // // // // // // // // // // //     if(root==nullptr)  return nullptr;
// // // // // // // // // // // // // // // // //     if(root->val==x)  return root;
// // // // // // // // // // // // // // // // //     else{
// // // // // // // // // // // // // // // // //         BinaryTreeFind(root->left,x) || BinaryTreeFind(root->right,x);
// // // // // // // // // // // // // // // // //         return root;
// // // // // // // // // // // // // // // // //     }
// // // // // // // // // // // // // // // // // }

// // // // // // // // // // // // // // // // #pragma once
// // // // // // // // // // // // // // // // #include<stdio.h>
// // // // // // // // // // // // // // // // #include<stdlib.h>
// // // // // // // // // // // // // // // // #include<stdbool.h>
// // // // // // // // // // // // // // // // #include<assert.h>
// // // // // // // // // // // // // // // // typedef struct BinaryTreeNode * QDataType;

// // // // // // // // // // // // // // // // typedef struct QueueNode{
// // // // // // // // // // // // // // // // struct QueueNode * next;
// // // // // // // // // // // // // // // // QDataType data;
// // // // // // // // // // // // // // // // }QNode;

// // // // // // // // // // // // // // // // typedef struct Queue{
// // // // // // // // // // // // // // // // QNode * head;
// // // // // // // // // // // // // // // // QNode * tail;
// // // // // // // // // // // // // // // // int   size;
// // // // // // // // // // // // // // // // }Queue;

// // // // // // // // // // // // // // // // void QueueInit(Queue * pq);
// // // // // // // // // // // // // // // // void QueueDestroy(Queue * pq);
// // // // // // // // // // // // // // // // void QueuePush(Queue * pq,QDataType x);
// // // // // // // // // // // // // // // // void QueuePop(Queue * pq);
// // // // // // // // // // // // // // // // int QueueSize(Queue * pq);
// // // // // // // // // // // // // // // // bool QueueEmpty(Queue * pq);
// // // // // // // // // // // // // // // // QDataType QueueFront(Queue * pq);
// // // // // // // // // // // // // // // // QDataType QueueBack(Queue * pq);

// // // // // // // // // // // // // // // // #include "Queue.h"
// // // // // // // // // // // // // // // // void QueueInit(Queue * pq){
// // // // // // // // // // // // // // // //     assert(pq);
// // // // // // // // // // // // // // // //     pq->head==pq->tail=NULL;
// // // // // // // // // // // // // // // //     pq->size=0;
// // // // // // // // // // // // // // // // }

// // // // // // // // // // // // // // // // void QueueDestroy(Queue * pq){
// // // // // // // // // // // // // // // // assert(pq);
// // // // // // // // // // // // // // // // QNode * cur=pq->head;
// // // // // // // // // // // // // // // // while(cur){
// // // // // // // // // // // // // // // //     QNode * next=cur->next;
// // // // // // // // // // // // // // // //     free(cur);
// // // // // // // // // // // // // // // //     cur=next;
// // // // // // // // // // // // // // // // }
// // // // // // // // // // // // // // // // pq->head==pq->tail==NULL;
// // // // // // // // // // // // // // // // pq->size=0;
// // // // // // // // // // // // // // // // }

// // // // // // // // // // // // // // // // void QueuePush(Queue * pq,QDataType x){
// // // // // // // // // // // // // // // // assert(pq);
// // // // // // // // // // // // // // // //         QNode * newnode=(QNode *)malloc(sizeof(QNode));
// // // // // // // // // // // // // // // //      if(newnode==nullptr)   {
// // // // // // // // // // // // // // // // perror("malloc fail");
// // // // // // // // // // // // // // // // return ;
// // // // // // // // // // // // // // // //      }
// // // // // // // // // // // // // // // //      newnode->data=x;
// // // // // // // // // // // // // // // //      newnode->next=nullptr;
// // // // // // // // // // // // // // // //      if(pq->head==NULL) {
// // // // // // // // // // // // // // // //         pq->head=pq->tail=newnode;
// // // // // // // // // // // // // // // //      }
// // // // // // // // // // // // // // // //      else  pq->tail->next=newnode;
// // // // // // // // // // // // // // // //      pq->tail=newnode;
// // // // // // // // // // // // // // // //      pq->size++;
// // // // // // // // // // // // // // // // }


// // // // // // // // // // // // // // // // void QueuePop(Queue * pq){
// // // // // // // // // // // // // // // // assert(pq);
// // // // // // // // // // // // // // // // if(pq->size==0)  return;
// // // // // // // // // // // // // // // // if(pq->head==pq->tail)  {free(pq->head);
// // // // // // // // // // // // // // // // pq->size--;
// // // // // // // // // // // // // // // // return ;}
// // // // // // // // // // // // // // // //   QNode * cur=pq->head;
// // // // // // // // // // // // // // // //   while(cur->next->next){
// // // // // // // // // // // // // // // //      cur=cur->next->next;
// // // // // // // // // // // // // // // //   }
// // // // // // // // // // // // // // // //         free(cur->next);
// // // // // // // // // // // // // // // //        pq->tail==cur;
// // // // // // // // // // // // // // // //        pq->size--;

// // // // // // // // // // // // // // // // }


// // // // // // // // // // // // // // // // int QueueSize(Queue * pq)
// // // // // // // // // // // // // // // // {
// // // // // // // // // // // // // // // //     assert(pq);
// // // // // // // // // // // // // // // //     return pq->size;
// // // // // // // // // // // // // // // // }
// // // // // // // // // // // // // // // // bool QueueEmpty(Queue * pq){
// // // // // // // // // // // // // // // //     assert(pq);
// // // // // // // // // // // // // // // //     return pq->size==0;
// // // // // // // // // // // // // // // // }


// // // // // // // // // // // // // // // // bool QueueEmpty(Queue * pq){
// // // // // // // // // // // // // // // //     assert(pq);
// // // // // // // // // // // // // // // //     return pq->size==0;
// // // // // // // // // // // // // // // // }

// // // // // // // // // // // // // // // // QDataType  QueueFront(Queue * pq){
// // // // // // // // // // // // // // // //     assert(pq);
// // // // // // // // // // // // // // // //     assert(!QueueEmpty(pq));
// // // // // // // // // // // // // // // //    pq->head->data;
// // // // // // // // // // // // // // // // }

// // // // // // // // // // // // // // // //判断一棵树是否为完全二叉树
// // // // // // // // // // // // // // // bool TreeComplete(BTNode * root){
// // // // // // // // // // // // // // // Queue q;
// // // // // // // // // // // // // // // QueueInit(&q);
// // // // // // // // // // // // // // // if(root)  QueuePush(&q,root);
// // // // // // // // // // // // // // // while(!QueueEmpty(&q))
// // // // // // // // // // // // // // // {BTNode * front=QueueFront(&q);
// // // // // // // // // // // // // // // QueuePop(&q);
// // // // // // // // // // // // // // // if(front==NULL)  break;
// // // // // // // // // // // // // // // else{
// // // // // // // // // // // // // // //     QueuePush(&q,front->left);
// // // // // // // // // // // // // // //     QueuePush(&q,front->right);
// // // // // // // // // // // // // // // }
// // // // // // // // // // // // // // // }
// // // // // // // // // // // // // // // //判断是不是完全二叉树
// // // // // // // // // // // // // // // while(!QueueEmpty(&q)){
// // // // // // // // // // // // // // //     BTNode * front=QueueFront(&q);
// // // // // // // // // // // // // // //     return false;
// // // // // // // // // // // // // // // }
// // // // // // // // // // // // // // // }
// // // // // // // // // // // // // // // QueueDestroy(&q);
// // // // // // // // // // // // // // // return true;
// // // // // // // // // // // // // // // }

// // // // // // // // // // // // // // //插入排序升序
// // // // // // // // // // // // // // void InsertSort(int *a,int n){
// // // // // // // // // // // // // // for(int i=1;i<n;i++){
// // // // // // // // // // // // // //     int end=i-1;
// // // // // // // // // // // // // //     int tmp=a[i];
// // // // // // // // // // // // // //     while(end>=0){
// // // // // // // // // // // // // //         if(tmp<a[end]){
// // // // // // // // // // // // // //             a[end+1]=a[end];
// // // // // // // // // // // // // //             --end;
// // // // // // // // // // // // // //         }
// // // // // // // // // // // // // //         else break;
// // // // // // // // // // // // // //     }
// // // // // // // // // // // // // //     a[end+1]=tmp;
// // // // // // // // // // // // // // }
// // // // // // // // // // // // // // }

// // // // // // // // // // // // // void InsertSort(int * a,int n){
// // // // // // // // // // // // // for(int i=1;i<n;i++){
// // // // // // // // // // // // //     int end=i-1;
// // // // // // // // // // // // //     int tmp=a[i];
// // // // // // // // // // // // //     while(end>=0){
// // // // // // // // // // // // //         if(tmp<a[end]){
// // // // // // // // // // // // //             a[end+1]=a[end];
// // // // // // // // // // // // //             --end;
// // // // // // // // // // // // //         }
// // // // // // // // // // // // //         else break;
// // // // // // // // // // // // //     }
// // // // // // // // // // // // //     a[end+1]=tmp;

// // // // // // // // // // // // // }

// // // // // // // // // // // // // }

// // // // // // // // // // // // //希尔排序
// // // // // // // // // // // // //希尔排序
// // // // // // // // // // // // void ShellSort(int* arr, int n)
// // // // // // // // // // // // {
// // // // // // // // // // // // 	int gap = n;
// // // // // // // // // // // // 	while (gap>1)
// // // // // // // // // // // // 	{
// // // // // // // // // // // // 		//每次对gap折半操作
// // // // // // // // // // // // 		gap = gap / 2;
// // // // // // // // // // // // 		//单趟排序
// // // // // // // // // // // // 		for (int i = 0; i < n - gap; ++i)
// // // // // // // // // // // // 		{
// // // // // // // // // // // // 			int end = i;
// // // // // // // // // // // // 			int tem = arr[end + gap];
// // // // // // // // // // // // 			while (end >= 0)
// // // // // // // // // // // // 			{
// // // // // // // // // // // // 				if (tem < arr[end])
// // // // // // // // // // // // 				{
// // // // // // // // // // // // 					arr[end + gap] = arr[end];
// // // // // // // // // // // // 					end -= gap;
// // // // // // // // // // // // 				}
// // // // // // // // // // // // 				else
// // // // // // // // // // // // 				{
// // // // // // // // // // // // 					break;
// // // // // // // // // // // // 				}
// // // // // // // // // // // // 			}
// // // // // // // // // // // // 			arr[end + gap] = tem;
// // // // // // // // // // // // 		}
// // // // // // // // // // // // 	}
// // // // // // // // // // // // }



// // // // // // // // // // // #pragma once
// // // // // // // // // // // #include<stdio.h>
// // // // // // // // // // // #include<stdbool.h>
// // // // // // // // // // // #include<stdlib.h>
// // // // // // // // // // // #include<time.h>

// // // // // // // // // // // void PrintArray
// // // // // // // // // // void swap(int *a,int *b){
// // // // // // // // // //     int  tmp=*a;
// // // // // // // // // //     *a=*b;
// // // // // // // // // //     *b=tmp;
// // // // // // // // // // }

// // // // // // // // // // void SelectSort(int *arr,int n){
// // // // // // // // // // int begin=0,end=n-1;
// // // // // // // // // // while(begin<=end){
// // // // // // // // // // int maxi=begin;   int mini=begin;
// // // // // // // // // // for(int i=begin;i<=end;++i){
// // // // // // // // // //     if(arr[i]<arr[mini])
// // // // // // // // // //     mini=i;
// // // // // // // // // //     if(arr[i]>arr[maxi])  maxi=i;
// // // // // // // // // // }
// // // // // // // // // // swap(&arr[mini],&arr[begin]);
// // // // // // // // // // if(begin==maxi)  maxi=mini;
// // // // // // // // // // swap(&arr[maxi],&arr[end]);
// // // // // // // // // // ++begin;
// // // // // // // // // // --end;
// // // // // // // // // // }
// // // // // // // // // // }



// // // // // // // // // // // //冒泡排序
// // // // // // // // // // // void BubbleSort(int* arr, int n)
// // // // // // // // // // // {
// // // // // // // // // // // 	int end = n;
// // // // // // // // // // // 	while (end)
// // // // // // // // // // // 	{
// // // // // // // // // // // 		int flag = 0;
// // // // // // // // // // // 		for (int i = 1; i < end; ++i)
// // // // // // // // // // // 		{
// // // // // // // // // // // 			if (arr[i - 1] > arr[i])
// // // // // // // // // // // 			{
// // // // // // // // // // // 				int tem = arr[i];
// // // // // // // // // // // 				arr[i] = arr[i - 1];
// // // // // // // // // // // 				arr[i - 1] = tem;
// // // // // // // // // // // 				flag = 1;
// // // // // // // // // // // 			}
// // // // // // // // // // // 		}
// // // // // // // // // // // 		if (flag == 0)
// // // // // // // // // // // 		{
// // // // // // // // // // // 			break;
// // // // // // // // // // // 		}
// // // // // // // // // // // 		--end;
// // // // // // // // // // // 	}
// // // // // // // // // // // }


// // // // // // // // // // //快速排序
// // // // // // // // // // void QuickSort(int *arr,int begin,int end){
// // // // // // // // // // if(begin>=end)  return;
// // // // // // // // // // int left=begin;
// // // // // // // // // // int right=end;
// // // // // // // // // // int keyi=begin;
// // // // // // // // // // while(begin<end){
// // // // // // // // // // while(arr[end]>=arr[keyi]&&begin<end)  --end;
// // // // // // // // // // while(arr[begin]<=arr[keyi]&&begin<end)  ++begin;
// // // // // // // // // // swap(arr[begin],arr[end]);
// // // // // // // // // // }
// // // // // // // // // // swap(arr[keyi],arr[end]);
// // // // // // // // // // keyi=end;
// // // // // // // // // // QuickSort(arr, left, keyi - 1);
// // // // // // // // // // 	QuickSort(arr,keyi + 1,right);
// // // // // // // // // // }

// // // // // // // // // //挖坑法
// // // // // // // // // void QuickSort1(int *arr,int begin,int end){
// // // // // // // // // if(begin)




// // // // // // // // // }


// // // // // // // // //非递归版本的希尔排序
// // // // // // // // int PartSort(int *arr,int begin,int end){//单趟排
// // // // // // // // int key=arr[begin];  
// // // // // // // // int cur=begin;
// // // // // // // // while(begin<end){
// // // // // // // // while(begin<end&&arr[end]>=key)  --end;
// // // // // // // // while(begin<end&&arr[begin]<=key)  ++begin;
// // // // // // // // swap(&arr[begin],&arr[end]);
// // // // // // // // }
// // // // // // // // swap(&arr[cur],&arr[begin]);

// // // // // // // // int meei=begin;
// // // // // // // // return meeti;
// // // // // // // // }


// // // // // // // // void  QuickSortNoR(int * arr,int begin,int end){
// // // // // // // // stack<int>st;
// // // // // // // // //先入右边
// // // // // // // // st.push(end);
// // // // // // // // //再入左边
// // // // // // // // st.push(begin);
// // // // // // // // while(!st.Empty()){
// // // // // // // // //左区间
// // // // // // // // int left=st.top();
// // // // // // // // st.pop();
// // // // // // // // //右区间
// // // // // // // // int right=st.top();
// // // // // // // // st.pop();
// // // // // // // // //中间数
// // // // // // // // int mid=PartSort(arr,left,right);
// // // // // // // // //当左区间>=mid-1时则证明左区间已经排好序了
// // // // // // // // if(left<mid-1){
// // // // // // // //     st.push(mid-1);
// // // // // // // //     st.push(left);
// // // // // // // // }
// // // // // // // // if(right>mid+1){
// // // // // // // //     st.push(right);
// // // // // // // //     st.push(mid+1);
// // // // // // // // }
// // // // // // // // }
// // // // // // // // }



// // // // // // // //前后指针法
// // // // // // // int Partition(int *arr,int left,int right){
// // // // // // // int pivot=arr[right];
// // // // // // // int pre=left-1;
// // // // // // // for(int cur=left;cur<right;cur++){
// // // // // // //     if(arr[cur]<pivot) {
// // // // // // //         ++pre;  swap(arr[pre],arr[cur]);
// // // // // // //     }
// // // // // // // }
// // // // // // // swap(arr[pre+1],arr[right]);
// // // // // // // return pre+1;
// // // // // // // }




// // // // // // // void QuickSort(int *arr,int left,int right){
// // // // // // // if(left>=right)   return;

// // // // // // // int pivotIndex=Partition(arr,left,right);
// // // // // // //   QuickSort(arr, left, pivotIndex - 1);
// // // // // // //     QuickSort(arr, pivotIndex + 1, right);

// // // // // // // }

// // // // // // // void Merge(int *arr,int left,int mid,int right,int *temp){
// // // // // // // int i=left;
// // // // // // // int j=mid+1;
// // // // // // // int k=0;
// // // // // // // while(i<=mid&&j<=right){
// // // // // // //     if(arr[i]<arr[j])  temp[k++]==arr[i++];
// // // // // // //     else temp[k++]=arr[j++]
// // // // // // // }
// // // // // // // while(i<=mid)  temp[k++]=arr[i++];
// // // // // // // while(j<=right)  temp[k++]=arr[j++];
// // // // // // // for(int m=0;m<k;m++)
// // // // // // // arr[left+m]=temp[m];



// // // // // // // }
// // // // // // // void MergeSort(int *arr,int left,int right,int * temp){
// // // // // // //     if(left>=right)  return;
// // // // // // //     int mid=(left+right)/2;
// // // // // // //     MergeSort(arr,left,mid,temp);
// // // // // // //     MergeSort(arr,mid+1,right,temp);
// // // // // // //     Merge(arr,left,mid,right,temp);
// // // // // // // }

// // // // // // //迭代法
// // // // // // //统一迭代法的本质在于: 把所有要访问的节点（无论是访问值还是访问左右子树)都先放入栈中，然后根据是否是“真正访问节点”来判断是否要收集结果
 
// // // // // //  //迭代法中序遍历
// // // // // //  class Solution{
// // // // // // public:
// // // // // // vector<int>inorderTraversal(TreeNode * root){
// // // // // // vector<int>res;
// // // // // // stack<TreeNode *>st;
// // // // // // if(root!=nullptr)  st.push(root);
// // // // // // while(!st.empty()){
// // // // // // TreeNode *ele=st.top();
// // // // // // if(ele!=nullptr)//说明是第一次
// // // // // // {st.pop();
// // // // // //    if(ele->right) st.push(ele->right);
// // // // // //     st.push(ele);
// // // // // //     st.push(nullptr);
// // // // // //     if(ele->left) st.push(ele->left);
// // // // // // }
// // // // // // else {
// // // // // //     //该收割了
// // // // // //     st.pop();
// // // // // //     TreeNode *t=st.top();
// // // // // //     st.pop();
// // // // // //     res.push_back(t->val);
// // // // // // }
// // // // // // }
// // // // // // }
// // // // // // return res;
// // // // // // };



// // // // // class Solution{
// // // // // public:
// // // // // vector<int>inorderTraversal(TreeNode * root){
// // // // //     vector<int>result;
// // // // //     stack<pair<TreeNode *,bool>>st;
// // // // //     if(root!=nullptr)   
// // // // //     st.push(make_pair(root,false));//false为默认值
// // // // //     while(!st.empty()){
// // // // //         auto node=st.top().first;
// // // // //         auto visited=st.top().second;//多加一个参数，使得迭代统一写法成为一件简单的事
// // // // //          if(visited){
// // // // //             result.push_back(node->val);
// // // // //             continue;
// // // // //          }
// // // // //          //visited当前为false,表示初次访问本节点
// // // // //          //中序遍历是"左中右",右儿子最先入栈，最后出栈
// // // // //          if(node->right)  st.push(make_pair(node->right,false));
// // // // //          //把自己加回到栈中，位置居中
// // // // //          //同时，设置visited
// // // // //          st.push(make_pair(node,true));
// // // // //          if(node->left)  st.push(make_pair(node->left,false)); 
  
// // // // //     }
    
// // // // // return result;
// // // // // }
// // // // // };
// // // // class Solution{
// // // // public: 
// // // // TreeNode * invertTree(TreeNode * root){
// // // // stack<TreeNode *>st;
// // // // if(root!=nullptr)   st.push(root);
// // // // while(!st.empty()){
// // // //      TreeNode * node=st.top();
// // // //       if(node!=nullptr) {
// // // //         st.pop();
// // // //         if(node->right)   st.push(node->right);
// // // //         st.push(node);
// // // //         st.push(nullptr);
// // // //         if(node->left)  st.push(node->left);
// // // //       }
// // // //       else{
// // // //         st.pop();
// // // //         node=st.pop();
// // // //         st.pop();
// // // //         swap(node->left,node->right);
// // // //       }
// // // // }
// // // //    return  root;

// // // // }



// // // // };
// // // int  leftheight(TreeNode * root){
// // // int h=0;
// // // while(root){
// // //     root=root->left;
// // //     h++;
// // // }
// // // return h;
// // // }

// // // int countNodes(TreeNode * root){
// // // if(!root)  return 0;
// // // int lh=leftheight(root->left);
// // // int rh=leftheight(root->right);
// // // if(lh=rh)   //左子树是满二叉树
// // // return (1<<lh)+countNodes(root->right);
// // // else{//右子树是满二叉树
// // // return (1<<rh)+countNodes(root->left);
// // // }
// // // }


// // bool isBalanced(TreeNode * root){
// // stack<TreeNode*>st;
// // if(root==nullptr)  return true;
// // //red-black tree  红黑树
// // }

// class Solution{
// public:
// vector<string>binaryTreePaths(TreeNode * root){
// stack<TreeNode *>treeSt;
// stack<string>pathSt;
// vector<stinig>result;
// if(root==nullptr)  return result;
// treeSt.push(root);
// pathSt.push(to_string(root->val));
// while(!treeSt.empty()){
//     TreeNode * node=treeSt.top();  treeSt.pop();
//     string path=pathSt.top();  pathSt.pop();
//     if(node->left==nullptr &&node->right==nullptr)  result.push_back(path);
//     if(node->right){
//         treeSt.push(node->right);
//         pathSt.push(path+"->"+to_string(node->right->val));
//     }
    
// }
// }
// };

// static_cast<double>(a);
int a=10;
static_cast<double>(a);

dynamic_cast<Derived *>(expression) //运行时安全的类型转换，用于多态类之间的指针或引用转换

const_cast<type>(expression)//用于添加或移除const,volatile属性
const int a=10;
int * p=const_cast<int *>(&a);

int * p=new int(65);
char * c=reinterpret_cast<char *>(p);

 