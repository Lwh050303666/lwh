隐式类型转换
整型提升
定义：

C语言中字节数少于整型字节数的数据类型在进行整型运算时，该类型的数据会被默认转为整型数据。

理解：

运算器（ALU），其操作对象的字节大小被要求至少是int的字节数。数据在被运算时，数据并不是直接在ALU上存储的，而是存储在CPU的寄存器（register）中，而通用寄存器的字节大小与ALU操作数的字节大小保持一致。针对小于4byte的数据类型，会默认转化为整型数据

情况：

在数据类型为char（1byte）/short（2byte）时，需要考虑整型提升。

char：

当数据在-128~127之间时，可以用8bits（1byte）表示，不需要整型提升。但当数据超过时候则需要。

unsigned char：

当数据在0~255之间，不需要考虑整型提升。

转化方法：
位扩展（从窄类型到宽类型）

无符号类型（unsigned char、unsigned short 等）：零扩展 ——高位全部填 0，低位保留原值。​
informit.com

有符号类型（signed char、short 等）：符号扩展 ——将原符号位（最高位）的值复制到高位，低位保留原值。​
informit.com      例如：int main()
{
    char a=3；
    char b=127；
    char c=a+b;
    printf("%d",c);
}
————————————————
隐式类型转换总结：

存入数据时（char a=-1；char b=255）：存入补码，按照数据类型进行截断，例如char，则只保留8个bit

计算数据时（char c=a+b）：按照原数据类型进行整型提升，然后用补码相加减，再次截断存入（8位）

输出数据时（printf（"%d/%u"））:按照原数据类型进行整型提升，经过反码转化为原码（32位），最后根据%d/%u输出数据

double ←── float 高

↑

long

↑ unsigned

↑ int ←── char,short 低








char * strtok ( char * str, const char * delimiters );/*1.定义
分解字符串为一组字符串。s为要分解的字符，delim为分隔符字符（如果传入字符串，则传入的字符串中每个字符均为分割符）。首次调用时，s指向要分解的字符串，之后再次调用要把s设成NULL。在头文件#include<string.h>中。
2.原型
char *strtok(char s[], const char *delim);
3.说明
（1）当strtok()在参数s的字符串中发现参数delim中包含的分割字符时,则会将该字符改为\0 字符。在第一次调用时，strtok()必需给予参数s字符串，往后的调用则将参数s设置成NULL。每次调用成功则返回指向被分割出片段的指针。
（2）返回值

从s开头开始的一个个被分割的串。当s中的字符查找到末尾时，返回NULL。如果查找不到delim中的字符时，返回当前strtok的字符串的指针。所有delim中包含的字符都会被滤掉，并将被滤掉的地方设为一处分割的节点。

（3）需要注意的是，使用该函数进行字符串分割时，会破坏被分解字符串的完整，调用前和调用后的s已经不一样了。第一次分割之后，原字符串str是分割完成之后的第一个字符串，剩余的字符串存储在一个静态变量中，因此多线程同时访问该静态变量时，则会出现错误。

4.使用
strtok函数会破坏被分解字符串的完整，调用前和调用后的s已经不一样了。如果要保持原字符串的完整，可以使用strchr和sscanf的组合等。*/





















            
