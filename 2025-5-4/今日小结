现在已然是2025年5月5日的凌晨一点钟，这两天忙着忙着忘了写每日小结了所以这算是这几天的综合了，总的来说，这几天搞了AVL树和REDBLACK树还有哈希结构，总体来说收获颇丰，5月4日晚饭时我刷B站视频时刷到了如何才能锻炼人的思维，其中讲最有效的方式就是通过每日练习写作，因为写作在某种意义上可以算是个人思维活动的一种可视化表达，通过整理自己的写作方式就是在某种程度上调整自己的思维方式，那么从今天开始我就要逐步去锻炼自己的写作能力以此来达到锻炼思维的目的，废话少说，直接开始。
其一，AVL树和REDBLACK树是数学家发明的，其实大多数算法的底层都是严谨的数学证明，如果想在计算机领域拥有非凡的成就的话，那么拥有很强的数学能力是必要的，不过这种能力貌似更多地来自于天赋，与大多数人无缘，所以我们只要学会合理地掌握并利用这些算法来解决现实工程中的问题，目前我觉得我掌握地还行，起码树旋转的规则以及REDBLACK树判断颜色以及黑色节点数量的方法我已经学会了，就是刚学的HASH结构有点生，感觉有点绕，日后还需要进一步加深理解和总结。
其二，我这几天在阅读瑞达利欧(Ray Dalio）的"PRINCIPAL"(原则）这本书，这本书主要讲人可以通过对现实世界的观察和总结来提炼出一套属于自己的“原则”来改善自己的生活以及达到想要达到的目标，目前我学习到了几点对我来说有用的：1.不要固收你对事物“应该”是什么样的看法，这会让你无法了解真实情况   2.通过快速试错以适应现实世界是无价的
3.把自己想象成一部在大机器里运转的小机器，并明白你有能力改变你的机器以实现更好的目标    4.永远做到主动发现问题，不容忍问题，诊断问题，探究根源，否则问题大概率会一遍遍重新上演

其三，我发现人的情绪是很害人的，我在很多时候虽然内心有某个目标（比如今天要做的事）但还是会忍不住干其他的事情（比如看短视频，看黄片），这种多巴胺会给人带来迅速及时的反馈，屡试不爽，这样会毁了一个人的，而且我今天刚了解到我的习惯非常不好（我习惯在非常困的时候打开黄色网站来给大脑寻找刺激使得大脑保持兴奋），而这种长时间习惯性的行为会给大脑造成不可逆的负面影响，这可能影响反馈机制，使得人越来越容易兴奋，人的神经具有可塑性，这就是为什么某些人可以在很大程度上改变自己的原因，如果我是机器人的话（可以机械地执行自己的原则）那么久而久之一定会取得比现在要多得多的成就，大多数的人都无法进行长期的坚持，因此越是把自己当成是一个机器人，这样就越有利。


VISUAL STUDIO中有“条件断点”这个概念，可以在某个位置打断点，然后只让它在符合特定的规则时才停止下来
在REDBLACK树中，旋转点是指在旋转操作中被移动的节点。在左旋操作中，旋转点通常是当前节点的右子节点;在右旋操作中，旋转点是当前节点的左子节点。旋转点在旋转过程中会改变其父子关系，从而调整树的结构。           中心点是指在旋转操作完成后，成为该子树新的根节点的节点。 中心点通常是旋转操作中被提升的节点，它在旋转后位于子树的中心位置，重新连接左右子树。


问题浮现
在类作用域一节中，我们介绍了三种名称，由于MyClass已经是一个完整的定义，因此编译期它的类型就可以确定下来，也就是说MyClass::A这些名称对于编译器来说也是已知的。

可是，如果是像T::iterator这样呢？T是模板中的类型参数，它只有等到模板实例化时才会知道是哪种类型，更不用说内部的iterator。通过前面类作用域一节的介绍，我们可以知道，T::iterator实际上可以是以下三种中的任何一种类型：

静态数据成员
静态成员函数
嵌套类型
前面例子中的ContainsAType::iterator是嵌套类型，完全没有问题。可如果是静态数据成员呢？如果实例化foo模板函数的类型是像这样的：

struct ContainsAnotherType {
    static int iterator;
    // ...

};
然后如此实例化foo的类型参数：

foo<ContainsAnotherType>();
那么，T::iterator * iter;被编译器实例化为ContainsAnotherType::iterator * iter;，这是什么？前面是一个静态成员变量而不是类型，那么这便成了一个乘法表达式，只不过iter在这里没有定义，编译器会报错：

error C2065: ‘iter’ : undeclared identifier

但如果iter是一个全局变量，那么这行代码将完全正确，它是表示计算两数相乘的表达式，返回值被抛弃。

同一行代码能以两种完全不同的方式解释，而且在模板实例化之前，完全没有办法来区分它们，这绝对是滋生各种bug的温床。这时C++标准委员会再也忍不住了，与其到实例化时才能知道到底选择哪种方式来解释以上代码，委员会决定引入一个新的关键字，这就是typename。

千呼万唤始出来
我们来看看C++标准：

A name used in a template declaration or definition and that is dependent on a template-parameter is assumed not to name a type unless the applicable name lookup finds a type name or the name is qualified by the keyword typename.

对于用于模板定义的依赖于模板参数的名称，只有在实例化的参数中存在这个类型名，或者这个名称前使用了typename关键字来修饰，编译器才会将该名称当成是类型。除了以上这两种情况，绝不会被当成是类型。

因此，如果你想直接告诉编译器T::iterator是类型而不是变量，只需用typename修饰：

template <class T>
void foo() {
    typename T::iterator * iter;
    // ...

}
这样编译器就可以确定T::iterator是一个类型，而不再需要等到实例化时期才能确定，因此消除了前面提到的歧义。





**理解按需编译**

用户询问了“按需编译”的含义，这似乎指的是“Just-In-Time (JIT) 编译”，即代码在执行之前进行编译。我觉得它可能也涉及到框架或像 CMake 这样的构建工具的按需编译功能。为了更准确地理解这个术语，我打算查看一下网络上的定义和解释，确保给出清晰、精确的回答。

**搜索按需编译**

我计划搜索“按需编译”相关的中文内容，找出相关页面。我会搜集定义和相关示例，为了确保信息多样性，我们需要引用至少10个来自不同领域的资源。可能会参考维基百科、博客文章、官方文档等。通过这些资源来整理出精炼且准确的信息，以帮助完成任务。


**拟定按需编译结构**

我打算提供一个按需编译的介绍，包括以下部分：

* 概述段：关键发现。
* 什么是按需编译？
* 工作原理
* 优缺点
* 应用场景

我会在每句后面引用相关的来源，以确保信息准确为用户提供更多详细的理解。此外，我会引用来自CSDN、知乎、维基百科等网站的文章，涵盖即时编译、静态编译、JIT与AOT的对比等相关要点。


已思考 19 秒


按需编译（Just‑In‑Time Compilation，JIT）是一种在程序执行过程中将中间代码或字节码动态编译为机器码的技术 ([维基百科，自由的百科全书][1], [维基百科，自由的百科全书][2])。它在程序启动阶段通常先使用解释器快速执行字节码，以实现低延迟启动；随后根据热点检测机制，将频繁执行的代码块编译并优化为机器码，从而在平衡启动速度与运行效率方面取得良好效果 ([CSDN博客][3], [美团技术团队][4])。该技术已被广泛应用于 Java 虚拟机（JVM）、.NET 运行时以及现代 JavaScript 引擎（如 V8）等环境 ([CSDN博客][5])。

## 什么是按需编译？

按需编译，又称即时编译（JIT），是在程序运行时而非启动前对代码进行编译的机制 ([维基百科，自由的百科全书][1])。它将源语言的中间表示（如 Java 字节码或 .NET MSIL）转换为本地机器码，并直接执行，无需事先全部预编译 ([CSDN博客][5])。
不同于 AOT（Ahead‑Of‑Time）预编译，按需编译只在真正“需要”时才对特定代码块进行转换，从而减少不必要的编译开销 ([CSDN博客][5])。

## 工作原理

1. **字节码解释**：程序启动后，解释器逐条执行字节码以快速响应用户操作 ([CSDN博客][6])。
2. **热点检测**：运行时统计方法或循环的调用频率，当某段代码执行次数超过阈值时标记为“热点” ([CSDN博客][3])。
3. **即时编译**：对标记的热点代码进行编译优化，生成高效的本地机器码，并将结果缓存起来 ([CSDN博客][3])。
4. **直接执行**：后续再次执行同一热点代码时，直接运行已编译的机器码，无需重新解释或编译 ([CSDN博客][3])。

## 优缺点

* **优点**

  * 启动快：初期依靠解释执行，避免一次性全部编译带来的长启动延迟 ([美团技术团队][4])。
  * 性能高：对热点代码应用高级优化，可达到接近静态编译的执行效率 ([CSDN博客][5])。

* **缺点**

  * 冷启动性能：首次执行时仍需解释，且编译过程本身会带来额外开销 ([知乎专栏][7])。
  * 实现复杂：需要设计高效的热点检测和多级优化策略，调试和维护成本较高 ([CSDN博客][8])。

## 应用场景

按需编译已经成为现代运行时系统的标配，典型应用包括：

* **JVM（Java 虚拟机）**：HotSpot VM 中的 C1/C2 编译器负责不同阶段的 JIT 优化 ([CSDN博客][3])。
* **.NET CLR**：使用 RyuJIT 对 MSIL 进行运行时编译和优化 ([CSDN博客][5])。
* **JavaScript 引擎**：如 V8、SpiderMonkey，通过多级 JIT（解释、Baseline、Optimizing）提升脚本执行速度 ([美团技术团队][4])。
* **动态语言运行时**：PyPy（Python）、LuaJIT（Lua）等项目依赖 JIT 技术大幅加速解释型语言的性能 ([美团技术团队][4])。





go to语句不能实现跨函数
C++中的异常：  如果throw的话就直接到catch地方，可以实现跨函数   如果多层调用并且 throw->catch的话栈帧也会还回去     抛出的异常必须被捕获，不捕获就要报错    假如是多层的try ->catch 的话那么只会跳到离它近的那一个
实际上，可以抛出派生类   用基类捕获
